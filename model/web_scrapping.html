<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keystroke and Mouse Behavior Tracking</title>
    <style>
        /* Add any styles if necessary */
    </style>
</head>
<body>
    <form id="inputForm">
        <input type="text" id="username" placeholder="Username" required>
        <input type="password" id="password" placeholder="Password" required>
        <button type="submit">Submit</button>
    </form>

    <script>
        // Feature variables
        let keystrokeTimes = [];
        let pauseTimes = [];
        let keyHoldTimes = [];
        let mouseMovements = [];
        let lastKeyPressTime = Date.now();
        let lastInputTime = Date.now();
        let keyHoldStartTime = 0;
        let errors = 0;
        let corrections = 0;
        let copyPasteFrequency = 0;

        // Capture keystroke times
        document.addEventListener('keydown', (event) => {
            const currentTime = Date.now();
            const keystrokeTime = currentTime - lastKeyPressTime;
            keystrokeTimes.push(keystrokeTime);
            lastKeyPressTime = currentTime;
            if (event.key === 'Backspace') errors++; // Count errors on Backspace
        });

        // Capture pauses
        document.addEventListener('input', (event) => {
            const currentTime = Date.now();
            const pauseTime = currentTime - lastInputTime;
            pauseTimes.push(pauseTime);
            lastInputTime = currentTime;
        });

        // Capture key hold times
        document.addEventListener('keydown', (event) => {
            keyHoldStartTime = Date.now();
        });

        document.addEventListener('keyup', (event) => {
            const currentTime = Date.now();
            const keyHoldTime = currentTime - keyHoldStartTime;
            keyHoldTimes.push(keyHoldTime);
            if (event.key !== 'Backspace') corrections++; // Count corrections on non-error keys
        });

        // Capture mouse movements and interactions
        document.addEventListener('mousemove', (event) => {
            mouseMovements.push({ x: event.clientX, y: event.clientY, time: Date.now() });
        });

        document.addEventListener('contextmenu', (event) => {
            copyPasteFrequency++;
        });

        // Handle form submission
        document.getElementById('inputForm').addEventListener('submit', (event) => {
            event.preventDefault(); // Prevent default form submission
            
            // Process and extract features
            const extractedFeatures = extractFeatures();
            console.log('Extracted Features:', extractedFeatures);

            // Save the features to CSV
            saveToCSV(extractedFeatures);
        });

        // Function to extract and calculate features
        function extractFeatures() {
            const avgKeystrokeTime = calculateAverage(keystrokeTimes);
            const stdKeystrokeTime = calculateStandardDeviation(keystrokeTimes, avgKeystrokeTime);
            const avgPauseTime = calculateAverage(pauseTimes);
            const stdPauseTime = calculateStandardDeviation(pauseTimes, avgPauseTime);
            const avgKeyHoldTime = calculateAverage(keyHoldTimes);
            const stdKeyHoldTime = calculateStandardDeviation(keyHoldTimes, avgKeyHoldTime);
            const typingSpeed = keystrokeTimes.length / ((Date.now() - lastInputTime) / 1000) || 0; // characters per second
            const rhythmConsistency = calculateRhythmConsistency(keystrokeTimes);
            const { avgDistance, stdDistance } = calculateMouseDistance(mouseMovements);
            const errorRate = errors / (keystrokeTimes.length || 1);
            const correctionRate = corrections / (errors || 1);
            const mouseSpeed = calculateMouseSpeed(mouseMovements);
            const mouseAcceleration = calculateMouseAcceleration(mouseMovements);
            const mouseJerk = calculateMouseJerk(mouseMovements);

            return {
                avg_keystroke_time: avgKeystrokeTime,
                std_keystroke_time: stdKeystrokeTime,
                avg_pause_time: avgPauseTime,
                std_pause_time: stdPauseTime,
                avg_key_hold_time: avgKeyHoldTime,
                std_key_hold_time: stdKeyHoldTime,
                typing_speed: typingSpeed,
                rhythm_consistency: rhythmConsistency,
                avg_key_distance: avgDistance,
                std_key_distance: stdDistance,
                error_rate: errorRate,
                correction_rate: correctionRate,
                copy_paste_frequency: copyPasteFrequency,
                mouse_speed: mouseSpeed,
                mouse_acceleration: mouseAcceleration,
                mouse_jerk: mouseJerk
            };
        }

        function saveToCSV(data) {
            const csvRows = [];
            const headers = Object.keys(data).join(',');
            csvRows.push(headers);

            const values = Object.values(data).join(',');
            csvRows.push(values);

            const csvString = csvRows.join('\n');
            const blob = new Blob([csvString], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.setAttribute('href', url);
            a.setAttribute('download', 'extracted_features.csv');
            a.click();
            URL.revokeObjectURL(url); // Clean up URL object
        }

        function calculateAverage(arr) {
            return arr.reduce((a, b) => a + b, 0) / arr.length || 0;
        }

        function calculateStandardDeviation(arr, mean) {
            return Math.sqrt(arr.reduce((acc, val) => acc + ((val - mean) ** 2), 0) / arr.length || 0);
        }

        function calculateRhythmConsistency(keystrokeTimes) {
            // Calculate rhythm consistency based on variance of keystroke times
            const mean = calculateAverage(keystrokeTimes);
            const stdDev = calculateStandardDeviation(keystrokeTimes, mean);
            return stdDev / mean; // Coefficient of variation
        }

        function calculateMouseDistance(mouseMovements) {
            let distances = [];
            for (let i = 1; i < mouseMovements.length; i++) {
                const dx = mouseMovements[i].x - mouseMovements[i - 1].x;
                const dy = mouseMovements[i].y - mouseMovements[i - 1].y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                distances.push(distance);
            }
            return {
                avgDistance: calculateAverage(distances),
                stdDistance: calculateStandardDeviation(distances, calculateAverage(distances))
            };
        }

        function calculateMouseSpeed(mouseMovements) {
            let speed = 0;
            for (let i = 1; i < mouseMovements.length; i++) {
                const dx = mouseMovements[i].x - mouseMovements[i - 1].x;
                const dy = mouseMovements[i].y - mouseMovements[i - 1].y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const time = (mouseMovements[i].time - mouseMovements[i - 1].time) / 1000; // seconds
                if (time > 0) {
                    speed += distance / time; // pixels per second
                }
            }
            return speed / (mouseMovements.length - 1 || 1);
        }

        function calculateMouseAcceleration(mouseMovements) {
            let accelerations = [];
            for (let i = 1; i < mouseMovements.length; i++) {
                const dx = mouseMovements[i].x - mouseMovements[i - 1].x;
                const dy = mouseMovements[i].y - mouseMovements[i - 1].y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const time = (mouseMovements[i].time - mouseMovements[i - 1].time) / 1000; // seconds
                const speed = distance / time; // pixels per second
                if (i > 1) {
                    const prevDx = mouseMovements[i - 1].x - mouseMovements[i - 2].x;
                    const prevDy = mouseMovements[i - 1].y - mouseMovements[i - 2].y;
                    const prevDistance = Math.sqrt(prevDx * prevDx + prevDy * prevDy);
                    const prevTime = (mouseMovements[i - 1].time - mouseMovements[i - 2].time) / 1000; // seconds
                    const prevSpeed = prevDistance / prevTime; // pixels per second
                    const acceleration = (speed - prevSpeed) / time; // pixels per second squared
                    accelerations.push(acceleration);
                }
            }
            return calculateAverage(accelerations) || 0;
        }

        function calculateMouseJerk(mouseMovements) {
            let jerks = [];
            for (let i = 1; i < mouseMovements.length; i++) {
                const dx = mouseMovements[i].x - mouseMovements[i - 1].x;
                const dy = mouseMovements[i].y - mouseMovements[i - 1].y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const time = (mouseMovements[i].time - mouseMovements[i - 1].time) / 1000; // seconds
                const speed = distance / time; // pixels per second

                if (i > 1) {
                    const prevDx = mouseMovements[i - 1].x - mouseMovements[i - 2].x;
                    const prevDy = mouseMovements[i - 1].y - mouseMovements[i - 2].y;
                    const prevDistance = Math.sqrt(prevDx * prevDx + prevDy * prevDy);
                    const prevTime = (mouseMovements[i - 1].time - mouseMovements[i - 2].time) / 1000; // seconds
                    const prevSpeed = prevDistance / prevTime; // pixels per second

                    const jerk = (speed - prevSpeed) / time; // pixels per second cubed
                    jerks.push(jerk);
                }
            }
            return calculateAverage(jerks) || 0;
        }
    </script>
</body>
</html>
